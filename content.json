{"meta":{"title":"懒人小屋","subtitle":null,"description":null,"author":"vincent","url":"http://vincent890120.github.io"},"pages":[],"posts":[{"title":"Service—解析","slug":"Service解析","date":"2017-09-14T08:53:01.000Z","updated":"2017-09-22T03:28:21.000Z","comments":true,"path":"2017/09/14/Service解析/","link":"","permalink":"http://vincent890120.github.io/2017/09/14/Service解析/","excerpt":"","text":"Service—解析 熟悉了activity，不得不提到android的第二大组件—Service，如果说activity是面子工程，service可以算作是里子工程了。这篇文章主要介绍一下service的使用 一. service简介Service(服务)是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。服务可由其他应用组件启动（如Activity），服务一旦被启动将在后台一直运行，即使启动服务的组件（Activity）已销毁也不受影响。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。 定义：服务，属于Android中的计算型组件 作用：提供需要在后台长期运行的服务（如复杂计算、下载等等） 特点：长生命周期的、没有用户界面、在后台运行 二. 生命周期首先看一下官方给出的生命周期图 onCreate() 首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或onBind() 之前）。如果服务已在运行，则不会调用此方法，该方法只调用一次 onStartCommand() 当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果自己实现此方法，则需要在服务工作完成后，通过调用 stopSelf() 或 stopService() 来停止服务。（在绑定状态下，无需实现此方法。） onBind() 当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，必须返回 一个IBinder 接口的实现类，供客户端用来与服务进行通信。无论是启动状态还是绑定状态，此方法必须重写，但在启动状态的情况下直接返回 null。 onDestroy() 当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等，这是服务接收的最后一个调用。 onUnbind() 调用者与服务解除绑定时调用 ​ 一旦在项目的任何位置调用了 Context的 startService()方法，相应的服务就会启动起来，并回调 onStartCommand()方法。如果这个服务之前还没有创建过，onCreate()方法会先于onStartCommand()方法执行。服务启动了之后会一直保持运行状态，直到 stopService()或stopSelf()方法被调用。注意虽然每调用一次startService()方法，onStartCommand()就会执行一次，但实际上每个服务都只会存在一个实例。所以不管你调用了多少次 startService()方法， 只需调用一次 stopService()或 stopSelf()方法，服务就会停止下来了。 ​ 另外，还可以调用 Context的bindService()来获取一个服务的持久连接，这时就会回调服务中的 onBind()方法。类似地，如果这个服务之前还没有创建过，onCreate()方法会先于 onBind()方法执行。之后，调用方可以获取到 onBind()方法里返回的 IBinde对象的实例，这样就能自由地和服务进行通信了。只要调用方和服务之间的连接没有断开，服务就会一直保持运行状态。 当调用了 startService()方法后，又去调用 stopService()方法，这时服务中的 onDestroy() 方法就会执行，表示服务已经销毁了。类似地，当调用了 bindService()方法后，又去调用 unbindService()方法，onDestroy()方法也会执行，这两种情况都很好理解。 ​ 但是需要注意，我们是完全有可能对一个服务既调用了 startService()方法，又调用了 bindService()方法的， 这种情况下该如何才能让服务销毁掉呢？根据 Android系统的机制，一个服务只要被启动或者被绑定了之后，就会一直处于运行状态，必须要让以上两种条件同时不满足，服务才能被销毁。所以，这种情况下要同时调用 stopService()和 unbindService()方法，onDestroy()方法才会执行。 三. service的分类1. Service的类型service在不同的场景下，对应的服务也不相同，将服务进行分类 2. 特点 四.具体使用1. 本地Service 步骤1：新建子类继承Service类 需重写父类的onCreate()、onStartCommand()、onDestroy()和onBind() MyService.java 12345678910111213141516171819202122232425public class MyService extends Service &#123;//启动Service之后，就可以在onCreate()或onStartCommand()方法里去执行一些具体的逻辑//由于这里作Demo用，所以只打印一些语句 @Override public void onCreate() &#123; super.onCreate(); System.out.println(&quot;执行了onCreat()&quot;); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; System.out.println(&quot;执行了onStartCommand()&quot;); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); System.out.println(&quot;执行了onDestory()&quot;); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; 步骤2：构建Intent对象，并调用startService()启动Service、stopService停止服务 MainActivity.java 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button startService; private Button stopService; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); startService = (Button) findViewById(R.id.startService); stopService = (Button) findViewById(R.id.stopService); startService.setOnClickListener(this); startService.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; //点击启动Service Button case R.id.startService: //构建启动服务的Intent对象 Intent startIntent = new Intent(this, MyService.class); //调用startService()方法-传入Intent对象,以此启动服务 startService(startIntent); //点击停止Service Button case R.id.stopService: //构建停止服务的Intent对象 Intent stopIntent = new Intent(this, MyService.class); //调用stopService()方法-传入Intent对象,以此停止服务 stopService(stopIntent); &#125; &#125;&#125; 步骤3：在AndroidManifest.xml里注册Service 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;scut.carson_ho.demo_service&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; //注册Service服务 &lt;service android:name=&quot;.MyService&quot;&gt; &lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; 2.可通信的服务Service上面介绍的Service是最基础的，但只能单机使用，即无法与Activity通信 接下来将在上面的基础用法上，增设“与Activity通信”的功能，即使用绑定Service服务（Binder类、bindService()、onBind(）、unbindService()、onUnbind()） 步骤1：在新建子类继承Service类，并新建一个子类继承自Binder类、写入与Activity关联需要的方法、创建实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyService extends Service &#123; private MyBinder mBinder = new MyBinder(); @Override public void onCreate() &#123; super.onCreate(); System.out.println(&quot;执行了onCreat()&quot;); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; System.out.println(&quot;执行了onStartCommand()&quot;); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); System.out.println(&quot;执行了onDestory()&quot;); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; System.out.println(&quot;执行了onBind()&quot;); //返回实例 return mBinder; &#125; @Override public boolean onUnbind(Intent intent) &#123; System.out.println(&quot;执行了onUnbind()&quot;); return super.onUnbind(intent); &#125; //新建一个子类继承自Binder类 class MyBinder extends Binder &#123; public void service_connect_Activity() &#123; System.out.println(&quot;Service关联了Activity,并在Activity执行了Service的方法&quot;); &#125; &#125;&#125; 步骤2：在Activity通过调用MyBinder类中的public方法来实现Activity与Service的联系 即实现了Activity指挥Service干什么Service就去干什么的功能 MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button startService; private Button stopService; private Button bindService; private Button unbindService; private MyService.MyBinder myBinder; //创建ServiceConnection的匿名类 private ServiceConnection connection = new ServiceConnection() &#123; //重写onServiceConnected()方法和onServiceDisconnected()方法 //在Activity与Service建立关联和解除关联的时候调用 @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //实例化Service的内部类myBinder //通过向下转型得到了MyBinder的实例 myBinder = (MyService.MyBinder) service; //在Activity调用Service类的方法 myBinder.service_connect_Activity(); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); startService = (Button) findViewById(R.id.startService); stopService = (Button) findViewById(R.id.stopService); startService.setOnClickListener(this); stopService.setOnClickListener(this); bindService = (Button) findViewById(R.id.bindService); unbindService = (Button) findViewById(R.id.unbindService); bindService.setOnClickListener(this); unbindService.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; //点击启动Service case R.id.startService: //构建启动服务的Intent对象 Intent startIntent = new Intent(this, MyService.class); //调用startService()方法-传入Intent对象,以此启动服务 startService(startIntent); break; //点击停止Service case R.id.stopService: //构建停止服务的Intent对象 Intent stopIntent = new Intent(this, MyService.class); //调用stopService()方法-传入Intent对象,以此停止服务 stopService(stopIntent); break; //点击绑定Service case R.id.bindService: //构建绑定服务的Intent对象 Intent bindIntent = new Intent(this, MyService.class); //调用bindService()方法,以此停止服务 bindService(bindIntent,connection,BIND_AUTO_CREATE); //参数说明 //第一个参数:Intent对象 //第二个参数:上面创建的Serviceconnection实例 //第三个参数:标志位 //这里传入BIND_AUTO_CREATE表示在Activity和Service建立关联后自动创建Service //这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行 break; //点击解绑Service case R.id.unbindService: //调用unbindService()解绑服务 //参数是上面创建的Serviceconnection实例 unbindService(connection); break; default: break; &#125; &#125;&#125; 注意：onStartCommand()方法不会执行 3. 前台Service前台Service和后台Service（普通）最大的区别就在于： 前台Service在下拉通知栏有显示通知，但后台Service没有； 前台Service优先级较高，不会由于系统内存不足而被回收；后台Service优先级较低，当系统出现内存不足情况时，很有可能会被回收 用法很简单，只需要在原有的Service类对onCreate()方法进行稍微修改即可， 123456789101112131415161718192021@Override public void onCreate() &#123; super.onCreate(); System.out.println(&quot;执行了onCreat()&quot;); //添加下列代码将后台Service变成前台Service //构建&quot;点击通知后打开MainActivity&quot;的Intent对象 Intent notificationIntent = new Intent(this,MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this,0,notificationIntent,0); //新建Builer对象 Notification.Builder builer = new Notification.Builder(this); builer.setContentTitle(&quot;前台服务通知的标题&quot;);//设置通知的标题 builer.setContentText(&quot;前台服务通知的内容&quot;);//设置通知的内容 builer.setSmallIcon(R.mipmap.ic_launcher);//设置通知的图标 builer.setContentIntent(pendingIntent);//设置点击通知后的操作 Notification notification = builer.getNotification();//将Builder对象转变成普通的notification startForeground(1, notification);//让Service变成前台Service,并在系统的状态栏显示出来 &#125; 4. 远程service主要和ALDL和IPC相关，这里暂时不做介绍 五. 其他说明1. Service和线程的关系：Service是运行在主线程里的，也就是说如果你在Service里编写了非常耗时的代码，程序必定会出现ANR的。 你可能会惊呼，这不是坑爹么！？那我要Service又有何用呢？其实大家不要把后台和子线程联系在一起就行了，这是两个完全不同的概念。Android的后台就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。比如说一些应用程序，始终需要与服务器之间始终保持着心跳连接，就可以使用Service来实现。你可能又会问，前面不是刚刚验证过Service是运行在主线程里的么？在这里一直执行着心跳连接，难道就不会阻塞主线程的运行吗？当然会，但是我们可以在Service中再创建一个子线程，然后在这里去处理耗时逻辑就没问题了。 既然在Service里也要创建一个子线程，那为什么不直接在Activity里创建呢？这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。 2. Service的两种启动模式(1) 采用start的方式开启服务使用这种start方式启动的Service的生命周期如下：onCreate()—&gt;onStartCommand()（onStart()方法已过时） —&gt; onDestory() 说明：如果服务已经开启，不会重复的执行onCreate()， 而是会调用onStart()和onStartCommand()。服务停止的时候调用 onDestory()。服务只会被停止一次。 特点：一旦服务开启跟调用者(开启者)就没有任何关系了。开启者退出了，开启者挂了，服务还在后台长期的运行。开启者不能调用服务里面的方法。 (2) 采用bind的方式开启服务使用这种start方式启动的Service的生命周期如下：onCreate() —&gt;onBind()—&gt;onunbind()—&gt;onDestory() 注意：绑定服务不会调用onstart()或者onstartcommand()方法 特点：bind的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。绑定者可以调用服务里面的方法。","categories":[{"name":"service","slug":"service","permalink":"http://vincent890120.github.io/categories/service/"}],"tags":[{"name":"service","slug":"service","permalink":"http://vincent890120.github.io/tags/service/"}]},{"title":"Activity—四大启动模式","slug":"Activity的四大启动模式","date":"2017-09-13T07:36:41.000Z","updated":"2017-09-22T03:54:58.000Z","comments":true,"path":"2017/09/13/Activity的四大启动模式/","link":"","permalink":"http://vincent890120.github.io/2017/09/13/Activity的四大启动模式/","excerpt":"","text":"Activity—四大启动模式 在android开发，activity的跳转是最常用的功能，启动模式可以说是敲门的方式，这一节我们好好总结一下activity的四大敲门方式。 一、基础概念在开始介绍启动模式之前，我们先了解一下相关的一些基本概念，不然后面会一脸懵逼 1.任务栈任务栈Task，是一种用来放置Activity实例的容器，他是以栈的形式进行盛放，也就是所谓的先进后出，主要有2个基本操作：压栈和出栈，其所存放的Activity是不支持重新排序的，只能根据压栈和出栈操作更改Activity的顺序。 启动一个Application的时候，系统会为它默认创建一个对应的Task，用来放置根Activity。默认启动Activity会放在同一个Task中，新启动的Activity会被压入启动它的那个Activity的栈中，并且显示它。当用户按下回退键时，这个Activity就会被弹出栈，按下Home键回到桌面，再启动另一个应用，这时候之前那个Task就被移到后台，成为后台任务栈，而刚启动的那个Task就被调到前台，成为前台任务栈，Android系统显示的就是前台任务栈中的Top实例Activity。 2.任务栈的作用以往基于应用（application）的程序开发中，程序具有明确的边界，一个程序就是一个应用，一个应用为了实现功能可以采用开辟新线程甚至新进程来辅助，但是应用与应用之间不能复用资源和功能。而Android引入了基于组件开发的软件架构，虽然我们开发android程序，仍然使用一个apk工程一个Application的开发形式，但是对于Aplication的开发就用到了Activity、service等四大组件，其中的每一个组件，都是可以被跨应用复用的，这就是android的神奇之处。虽然组件可以跨应用被调用，但是一个组件所在的进程必须是在组件所在的Aplication进程中。由于android强化了组件概念，弱化了Aplication的概念，所以在android程序开发中，A应用的A组件想要使用拍照或录像的功能就可以不用去针对Camera类进行开发，直接调用系统自带的摄像头应用（称其B应用）中的组件（称其B组件）就可以了，但是这就引发了一个新问题，A组件运行在A应用中，B组件运行在B应用中，自然都不在同一个进程中，那么从B组件中返回的时候，如何实现正确返回到A组件呢？Task就是来负责实现这个功能的，它是从用户角度来理解应用而建立的一个抽象概念。因为用户所能看到的组件就是Activity，所以Task可以理解为实现一个功能而负责管理所有用到的Activity实例的栈。 栈是一个先进后出的线性表，根据Activity在当前栈结构中的位置，来决定该Activity的状态。正常情况下，当一个Activity启动了另一个Activity的时候，新启动的Activity就会置于任务栈的顶端，并处于活动状态，而启动它的Activity虽然成功身退，但依然保留在任务栈中，处于停止状态，当用户按下返回键或者调用finish()方法时，系统会移除顶部Activity，让后面的Activity恢复活动状态。当然，世界不可能一直这么“和谐”，可以给Activity设置一些“特权”，来打破这种“和谐”的模式，这种特权，就是通过在AndroidManifest文件中的属性andorid:launchMode来设置或者通过Intent的flag来设置的，下面就先介绍下Activity的几种启动模式。 3.taskAffinity 这个参数标识了一个Activity所需任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名 我们可以单独指定每一个Activity的taskAffinity属性覆盖默认值 一个任务的affinity决定于这个任务的根activity（root activity）的taskAffinity 在概念上，具有相同的affinity的activity（即设置了相同taskAffinity属性的activity）属于同一个任务 为一个activity的taskAffinity设置一个空字符串，表明这个activity不属于任何task 二、四大启动模式1.standard默认模式 可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。 应用场景：绝大多数Activity。 注意：如果以这种方式启动的Activity被跨进程调用，在5.0之前新启动的Activity实例会放入发送Intent的Task的栈的顶部，尽管它们属于不同的程序，这似乎有点费解看起来也不是那么合理，所以在5.0之后，上述情景会创建一个新的Task，新启动的Activity就会放入刚创建的Task中，这样就合理的多了。 2.singleTop栈顶复用模式 如果要开启的activity在任务栈的顶部已经存在，就不会创建新的实例，而是调用 onNewIntent() 方法。避免栈顶的activity被重复的创建。 应用场景：在通知栏点击收到的通知，然后需要启动一个Activity，这个Activity就可以用singleTop，否则每次点击都会新建一个Activity。当然实际的开发过程中，测试妹纸没准给你提过这样的bug：某个场景下连续快速点击，启动了两个Activity。如果这个时候待启动的Activity使用 singleTop模式也是可以避免这个Bug的。 singleTop模式分3种情况 当前栈中已有该Activity的实例并且该实例位于栈顶时，不会新建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent方法 当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例 当前栈中不存在该Activity的实例时，其行为同standard启动模式 注意：standard和singleTop启动模式都是在原任务栈中新建Activity实例，不会启动新的Task，即使你指定了taskAffinity属性。 3.singleTask栈内复用模式activity只会在任务栈里面存在一个实例。如果要激活的activity，在任务栈里面已经存在，就不会创建新的activity，而是复用这个已经存在的activity，调用 onNewIntent() 方法，并且清空这个activity任务栈上面所有的activity。其实这个过程还存在一个任务栈的匹配，因为这个模式启动时，会在自己需要的任务栈中寻找实例，这个任务栈就是通过taskAffinity属性指定。如果这个任务栈不存在，则会创建这个任务栈。 应用场景：大多数App的主页。对于大部分应用，当我们在主界面点击回退按钮的时候都是退出应用，那么当我们第一次进入主界面之后，主界面位于栈底，以后不管我们打开了多少个Activity，只要我们再次回到主界面，都应该使用将主界面Activity上所有的Activity移除的方式来让主界面Activity处于栈顶，而不是往栈顶新加一个主界面Activity的实例，通过这种方式能够保证退出应用时所有的Activity都能报销毁。在跨应用Intent传递时，如果系统中不存在singleTask Activity的实例，那么将创建一个新的Task，然后创建SingleTask Activity的实例，将其放入新的Task中。 4.singleInstance单一实例模式 整个手机操作系统里面只有一个实例存在。不同的应用去打开这个activity 共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。 应用场景：呼叫来电界面。这种模式的使用情况比较罕见，在Launcher中可能使用。或者你确定你需要使Activity只有一个实例。建议谨慎使用。 三、设置方式系统提供了两种方式来设置一个Activity的启动模式，除了在AndroidManifest文件中设置以外，还可以通过Intent的Flag来设置一个Activity的启动模式，下面我们在简单介绍下一些Flag。 FLAG_ACTIVITY_NEW_TASK 使用一个新的Task来启动一个Activity，但启动的每个Activity都讲在一个新的Task中。与指定android：launchMode=“singleInstance”效果相同 该Flag通常使用在从Service中启动Activity的场景，由于Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。 FLAG_ACTIVITY_SINGLE_TOP 使用singletop模式启动一个Activity，与指定android：launchMode=“singleTop”效果相同。 FLAG_ACTIVITY_CLEAR_TOP 使用SingleTask模式来启动一个Activity，与指定android：launchMode=“singleTask”效果相同。 FLAG_ACTIVITY_NO_HISTORY Activity使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在Activity栈中。 FLAG_ACTIVITY_CLEAR_TASK 如果在调用Context.startActivity时传递这个标记，将会导致任何用来放置该activity的已经存在的task里面的activity先清空，然后该activity再在该task中启动，也就是说，这个新启动的activity变成了这个空task的根activity。所有老的activity都结束掉。该标志位必须和FLAG_ACTIVITY_NEW_TASK一起使用。 一般登录页面使用该种启动方式。 四、其他1. LaunchMode与StartActivityForResult我们在开发过程中经常会用到StartActivityForResult方法启动一个Activity，然后在onActivityResult()方法中可以接收到上个页面的回传值，但你有可能遇到过拿不到返回值的情况，那有可能是因为Activity的LaunchMode设置为了singleTask。5.0之后，android的LaunchMode与StartActivityForResult的关系发生了一些改变。 这是因为ActivityStackSupervisor类中的startActivityUncheckedLocked方法在5.0中进行了修改。在5.0之前，当启动一个Activity时，系统将首先检查Activity的launchMode，如果为A页面设置为SingleInstance或者B页面设置为singleTask或者singleInstance,则会在LaunchFlags中加入FLAG_ACTIVITY_NEW_TASK标志，而如果含有FLAG_ACTIVITY_NEW_TASK标志的话，onActivityResult将会立即接收到一个cancle的信息，而5.0之后这个方法做了修改，修改之后即便启动的页面设置launchMode为singleTask或singleInstance，onActivityResult依旧可以正常工作，也就是说无论设置哪种启动方式，StartActivityForResult和onActivityResult()这一组合都是有效的。所以如果你目前正好基于5.0做相关开发，不要忘了向下兼容，这里有个坑请注意避让。 本文参考阅读： http://www.jianshu.com/p/2a9fcf3c11e4 http://blog.csdn.net/mynameishuangshuai/article/details/51491074","categories":[{"name":"activity","slug":"activity","permalink":"http://vincent890120.github.io/categories/activity/"}],"tags":[{"name":"activity","slug":"activity","permalink":"http://vincent890120.github.io/tags/activity/"}]},{"title":"Activity—生命周期","slug":"Activity—生命周期","date":"2017-09-12T08:29:43.000Z","updated":"2017-09-22T03:27:54.000Z","comments":true,"path":"2017/09/12/Activity—生命周期/","link":"","permalink":"http://vincent890120.github.io/2017/09/12/Activity—生命周期/","excerpt":"","text":"Activity—生命周期作为android四大组件，activity的作用对于每一个android开发来说都是非凡的。之前学习android，只知道7个生命周期，但是具体的详细的东西却不求甚解，这篇主要是深入了解一下生命周期，重新学习一下这个熟悉的activity。 上图是最基础的activity的生命周期的一个调用的过程 一、生命周期中各个方法的含义和作用1、7个生命周期的含义（1）onCreate:​ 它本身的作用是进行Activity的一些初始化工作，比如使用setContentView加载布局，对一些控件和变量进行初始化等。此时Activity还在后台，不可见。所以动画不应该在这里初始化，因为看不到…… （2）onStart：​ 此时Activity已经可见了，但是还没出现在前台，我们还看不到，无法与Activity交互。其实将Activity的初始化工作放在这也没有什么问题，放在onCreate中是由于官方推荐的以及我们开发的习惯。 （3）onResume:​ 此时Activity经过前两个阶段的初始化已经蓄势待发。Activity在这个阶段已经出现在前台并且可见了。这个阶段可以打开独占设备 （4）onPause:​ 当Activity要跳到另一个Activity或应用正常退出时都会执行这个方法。此时Activity在前台并可见，我们可以进行一些轻量级的存储数据和去初始化的工作，不能太耗时，因为在跳转Activity时只有当一个Activity执行完了onPause方法后另一个Activity才会启动，而且android中指定如果onPause在500ms即0.5秒内没有执行完毕的话就会强制关闭Activity。 （5）onStop：​ 此时Activity已经不可见了，但是Activity对象还在内存中，没有被销毁。这个阶段的主要工作也是做一些资源的回收工作。 （6）onDestroy：​ 这个阶段Activity被销毁，不可见，我们可以将还没释放的资源释放，以及进行一些回收工作。 （7）onRestart：​ Activity在这时可见，当用户按Home键切换到桌面后又切回来或者从后一个Activity切回前一个Activity就会触发这个方法。这里一般不做什么操作。 2、各个生命周期的区别 onCreate和onStart之间有什么区别？ （1）可见与不可见的区别。前者不可见，后者可见。（2）执行次数的区别。onCreate方法只在Activity创建时执行一次，而onStart方法在Activity的切换以及按Home键返回桌面再切回应用的过程中被多次调用。因此Bundle数据的恢复在onStart中进行比onCreate中执行更合适。（3）onCreate能做的事onStart其实都能做，但是onstart能做的事onCreate却未必适合做。如前文所说的，setContentView和资源初始化在两者都能做，然而想动画的初始化在onStart中做比较好。 onStart方法和onResume方法有什么区别？ （1）是否在前台。onStart方法中Activity可见但不在前台，不可交互，而在onResume中在前台。（2）职责不同，onStart方法中主要还是进行初始化工作，而onResume方法，根据官方的建议，可以做开启动画和独占设备的操作。 onPause方法和onStop方法有什么区别？ （1）是否可见。onPause时Activity可见，onStop时Activity不可见，但Activity对象还在内存中。（2）在系统内存不足的时候可能不会执行onStop方法，因此程序状态的保存、独占设备和动画的关闭、以及一些数据的保存最好在onPause中进行，但要注意不能太耗时。 onStop方法和onDestroy方法有什么区别？ onStop阶段Activity还没有被销毁，对象还在内存中，此时可以通过切换Activity再次回到该Activity，而onDestroy阶段Acivity被销毁 切换Activity时各方法的执行次序 (A)onPause→(B)onCreate→(B)onStart→(B)onResume→(A)onStop而不是(A)onPause→(A)onStop→(B)onCreate→(B)onStart→(B)onResume （1）一个Activity或多或少会占有系统资源，而在官方的建议中，onPause方法将会释放掉很多系统资源，为切换Activity提供流畅性的保障，而不需要再等多两个阶段，这样做切换更快。（2）按照生命周期图的表示，如果用户在切换Activity的过程中再次切回原Activity，是在onPause方法后直接调用onResume方法的，这样比onPause→onStop→onRestart→onStart→onResume要快得多。 onSaveInstanceState和onRestoreInstanceState onSaveInstanceState(1)在Activity被覆盖或退居后台之后，系统资源不足将其杀死，此方法会被调用； (2)在用户改变屏幕方向时，此方法会被调用； (3)在当前Activity跳转到其他Activity或者按Home键回到主屏，自身退居后台时，此方法会被调用。 第一种情况我们无法保证什么时候发生，系统根据资源紧张程度去调度； 第二种是屏幕翻转方向时，系统先销毁当前的Activity，然后再重建一个新的，调用此方法时，我们可以保存一些临时数据； 第三种情况系统调用此方法是为了保存当前窗口各个View组件的状态。onSaveInstanceState的调用顺序是在onPause之前。 onRestoreInstanceState(1)在Activity被覆盖或退居后台之后，系统资源不足将其杀死，然后用户又回到了此Activity，此方法会被调用； (2)在用户改变屏幕方向时，重建的过程中，此方法会被调用。我们可以重写此方法，以便可以恢复一些临时数据。onRestoreInstanceState的调用顺序是在onStart之后。 三、具体过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import android.app.Activity; import android.content.res.Configuration; import android.os.Bundle; import android.util.Log; public class LifeCycleActivity extends Activity &#123; private static final String TAG = &quot;OrientationActivity&quot;; private int param = 1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.orientation_portrait); Log.i(TAG, &quot;onCreate called.&quot;); &#125; @Override protected void onStart() &#123; super.onStart(); Log.i(TAG, &quot;onStart called.&quot;); &#125; @Override protected void onRestart() &#123; super.onRestart(); Log.i(TAG, &quot;onRestart called.&quot;); &#125; @Override protected void onResume() &#123; super.onResume(); Log.i(TAG, &quot;onResume called.&quot;); &#125; @Override protected void onPause() &#123; super.onPause(); Log.i(TAG, &quot;onPause called.&quot;); &#125; @Override protected void onStop() &#123; super.onStop(); Log.i(TAG, &quot;onStop called.&quot;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.i(TAG, &quot;onDestory called.&quot;); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; outState.putInt(&quot;param&quot;, param); Log.i(TAG, &quot;onSaveInstanceState called. put param: &quot; + param); super.onSaveInstanceState(outState); &#125; @Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; param = savedInstanceState.getInt(&quot;param&quot;); Log.i(TAG, &quot;onRestoreInstanceState called. get param: &quot; + param); super.onRestoreInstanceState(savedInstanceState); &#125; //当指定了android:configChanges=&quot;orientation&quot;后,方向改变时onConfigurationChanged被调用 @Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); Log.i(TAG, &quot;onConfigurationChanged called.&quot;); switch (newConfig.orientation) &#123; case Configuration.ORIENTATION_PORTRAIT: setContentView(R.layout.orientation_portrait); break; case Configuration.ORIENTATION_LANDSCAPE: setContentView(R.layout.orientation_landscape); break; &#125; &#125; &#125; 1.启动Activity： 在系统调用了onCreate和onStart之后，调用了onResume，自此，Activity进入了运行状态。 2.跳转到其他Activity，或按下Home键回到主屏： 我们看到，此时onSaveInstanceState方法在onPause之前被调用了，并且注意，退居后台时，onPause后onStop相继被调用。 3.从后台回到前台： 当从后台会到前台时，系统先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，Activity又进入了运行状态。 4.其他activity覆盖 修改TargetActivity在AndroidManifest.xml中的配置，将android:theme属性设置为@android:style/Theme.Dialog，然后再点击LifeCycleActivity中的按钮，跳转行为就变为了TargetActivity覆盖到LifeCycleActivity之上了，此时调用的方法为： 注意还有一种情况就是，我们点击按钮，只是按下锁屏键，执行的效果也是如上。 我们注意到，此时LifeCycleActivity的OnPause方法被调用，并没有调用onStop方法，因为此时的LifeCycleActivity没有退居后台，只是被覆盖或被锁屏；onSaveInstanceState会在onPause之前被调用。 5.按回退键 使LifeCycleActivity从被覆盖回到前面，或者按解锁键解锁屏幕： 此时只有onResume方法被调用，直接再次进入运行状态。 6.退出： 最后onDestory方法被调用，标志着LifeCycleActivity的终结。 大家似乎注意到，在所有的过程中，并没有onRestoreInstanceState的出现，这个并不奇怪，因为之前我们就说过，onRestoreInstanceState只有在杀死不在前台的Activity之后用户回到此Activity，或者用户改变屏幕方向的这两个重建过程中被调用。我们要演示第一种情况比较困难，我们可以结合第二种情况演示一下具体过程。顺便也向大家讲解一下屏幕方向改变的应对策略。 7.旋转屏幕 系统先是调用onSaveInstanceState方法，我们保存了一个临时参数到Bundle对象里面，然后当Activity重建之后我们又成功的取出了这个参数。 为了避免这样销毁重建的过程，我们需要在AndroidMainfest.xml中对OrientationActivity对应的配置android:configChanges=”orientation”，然后我们再测试一下，我试着做了四次的旋转，打印如下： 可以看到，每次旋转方向时，只有onConfigurationChanged方法被调用，没有了销毁重建的过程。 注意：如果配置了android:screenOrientation属性，则会使android:configChanges=”orientation”失效。","categories":[{"name":"activity","slug":"activity","permalink":"http://vincent890120.github.io/categories/activity/"}],"tags":[{"name":"activity","slug":"activity","permalink":"http://vincent890120.github.io/tags/activity/"}]},{"title":"自定义View","slug":"自定义View","date":"2016-05-26T09:15:41.000Z","updated":"2017-09-20T09:09:03.000Z","comments":true,"path":"2016/05/26/自定义View/","link":"","permalink":"http://vincent890120.github.io/2016/05/26/自定义View/","excerpt":"","text":"已经基本了解了view的创建过程，接下来我们就可以学习如何去真正意义上的自定义一个View主要有三种方式来自定义一个View，接下来会围绕着三种方式来介绍 View的基本方法常用的回调函数 onFinishInflate( ) 当View中所有的子控件均被映射成xml后触发 onMeasure(int, int) 确定所有子元素的大小 onSizeChanged(int, int, int, int) 当view的大小发生变化时触发 onLayout(boolean, int, int, int, int) 当View分配所有的子元素的大小和位置时触发 onDraw(Canvas) view渲染内容的细节 构造方法 在我们创建一个自定义View的时候，Andorid要求我们实现三个View的构造方法，你有没有想过这三个方法到底是什么作用呢？为什么Andorid要求我们去实现三个构造方法呢？ public CustomLifeCycleView(Context context) { super(context); } public CustomLifeCycleView(Context context, AttributeSet attrs) { super(context, attrs); } public CustomLifeCycleView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } 现在我们就逐个介绍一下这三个构造函数 CustomLifeCycleView(Context context) 这个函数最为简单，如果我们想通过代码来创建一个View，就会调用这个构造函数 CustomLifeCycleView(Context context, AttributeSet attrs) 在这个构造函数里面多了一个AttributeSet的参数，如果我们通过XML来创建一个View的时候，这个参数会将XML里设置的属性传递给构造函数，我们在之后的自定义View的过程中也会经常使用这个参数来设置。如果这个时候我们采用XML的方法来创建一个View，但是没有实现这个构造函数，那么运行的时候就会报错的 CustomLifeCycleView(Context context, AttributeSet attrs, int defStyleAttr) 我觉得最让人没法理解的就是这个方法了，在大多数的情况下，我们都没有使用过这个方法，但是既然Andorid把它搞出来了，肯定是有原因的，不如让我们好好研究一下这个蛋疼的构造函数。可以看见，这个构造函数又多了一新的参数：defStyleAttr在大多数情况下，第三个函数系统是不会调用的，需要显示的调用，例如在第二个函数里调用第三个函数。 第三个参数的意义就如同它的名字所说的，是默认的Style，只是这里没有说清楚，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，以系统中的Button为例说明。​ public Button(Context context) { this(context, null); } public Button(Context context, AttributeSet attrs) { this(context, attrs, com.android.internal.R.attr.buttonStyle); } public Button(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } 在Code中实例化View会调用第一个构造函数，在XML中定义会调用第二个构造函数，在Button的实现中都调用了第三个构造函数，并且defStyle的值是com.android.internal.R.attr.buttonStyle。 从文档中第三个构造函数的说明中可以看到，这个构造函数的作用是View的子类提供这个类的基础样式。 这个是它最根本的作用，现在看起来比较的抽象，我们进一步讨论一下他的作用。第一步我们先俩接一个函数：obtainStyledAtributes public TypedArray obtainStyledAttributes (AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes) ​ set：属性值的集合 attrs：我们要获取的属性的资源ID的一个数组，如同ContextProvider中请求数据库时的Projection数组，就是从一堆属性中我们希望查询什么属性的值 defStyleAttr：这个是当前Theme中的一个attribute，是指向style的一个引用，当在layout xml中和style中都没有为View指定属性时，会从Theme中这个attribute指向的Style中查找相应的属性值，这就是defStyle的意思，如果没有指定属性值，就用这个值，所以是默认值，但这个attribute要在Theme中指定，且是指向一个Style的引用，如果这个参数传入0表示不向Theme中搜索默认值 defStyleRes：这个也是指向一个Style的资源ID，但是仅在defStyleAttr为0或defStyleAttr不为0但Theme中没有为defStyleAttr属性赋值时起作用 知道了这个函数，我们就可以进一步说明了。其实第三个构造函数的作用就是提供一个基础的属性值。但是，为什么我们有的时候直接设置属性值，却并不起作用呢，别忘了，我们这个值是基础属性值，既然是基础，必然就会有一个优先级，因为同一个属性值在多个地方都可以进行定义的哦！先直接给出结论： XML中定义&gt;style定义&gt;defStyleAttr和defStyleRes指定的默认值&gt;在Theme中指定的值上面这个结论，相信大家一定看的很清楚了，XML，style和Theme大家经常使用，defStyleAttr和defStyleRes在前面的参数说明中已经说了。 这是为什么呢？ 代码是最好的语言，我们直接通过代码来分析一下，属性值的优先级首先定义style和attrs attrs.xml &lt;resources&gt; &lt;declare-styleable name=&quot;Customize&quot;&gt; &lt;attr name=&quot;attr_one&quot; format=&quot;string&quot; /&gt; &lt;attr name=&quot;attr_two&quot; format=&quot;string&quot; /&gt; &lt;attr name=&quot;attr_three&quot; format=&quot;string&quot; /&gt; &lt;attr name=&quot;attr_four&quot; format=&quot;string&quot; /&gt; &lt;/declare-styleable&gt; &lt;attr name=&quot;CustomizeStyle&quot; format=&quot;reference&quot; /&gt; &lt;/resources&gt; styles.xml &lt;resources&gt; &lt;style name=&quot;AppBaseTheme&quot; parent=&quot;android:Theme.Light&quot;&gt; &lt;/style&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;AppBaseTheme&quot;&gt; &lt;item name=&quot;attr_one&quot;&gt;attr one from theme&lt;/item&gt; &lt;item name=&quot;attr_two&quot;&gt;attr two from theme&lt;/item&gt; &lt;item name=&quot;attr_three&quot;&gt;attr three from theme&lt;/item&gt; &lt;item name=&quot;CustomizeStyle&quot;&gt;@style/CustomizeStyleInTheme&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;CustomizeStyleInTheme&quot;&gt; &lt;item name=&quot;attr_one&quot;&gt;attr one from theme reference&lt;/item&gt; &lt;item name=&quot;attr_two&quot;&gt;attr two from theme reference&lt;/item&gt; &lt;item name=&quot;attr_three&quot;&gt;attr three from theme reference&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;ThroughStyle&quot;&gt; &lt;item name=&quot;attr_one&quot;&gt;attr one from style&lt;/item&gt; &lt;item name=&quot;attr_two&quot;&gt;attr two from style&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;DefaultCustomizeStyle&quot;&gt; &lt;item name=&quot;attr_one&quot;&gt;attr one from defalut style res&lt;/item&gt; &lt;item name=&quot;attr_two&quot;&gt;attr two from defalut style res&lt;/item&gt; &lt;item name=&quot;attr_three&quot;&gt;attr three from defalut style res&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 然后定义对应的activity &lt;com.example.vincent.customview.View.CustomLifeCycleView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; ad:attr_one=&quot;attr one in xml&quot; style=&quot;@style/ThroughStyle&quot; /&gt; 在自定义的view中对这几个属性值进行打印，可以分析，​ public CustomLifeCycleView(Context context, AttributeSet attrs) { this(context, attrs, R.attr.CustomizeStyle); } public CustomLifeCycleView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.Customize, defStyleAttr, R.style.DefaultCustomizeStyle); String one = a.getString(R.styleable.Customize_attr_one); String two = a.getString(R.styleable.Customize_attr_two); String three = a.getString(R.styleable.Customize_attr_three); String four = a.getString(R.styleable.Customize_attr_four); Log.i(TAG, &quot;one:&quot; + one); Log.i(TAG, &quot;two:&quot; + two); Log.i(TAG, &quot;three:&quot; + three); Log.i(TAG, &quot;four:&quot; + four); a.recycle(); } 打印的结果​ one:attr one in xml two:attr two from style three:attr three from theme reference four:null attr_one同时在xml、style、defStyleAttr、defStyleRes与Theme中直接定义了值，但起作用的是在xml中的定义 attr_two同时在style、defStyleAttr、defStyleRes与Theme中直接定义了值，但起用的是在style中的定义 attr_three同时在defStyleAttr、defStyleRes与Theme中直接定义了值，但起作用的是defStyleAttr attr_four在defStyleRes中定义了，但结果仍是0。 最终结论： 要为自定义View自定义属性，可以通过declare-styleable声明需要的属性 为了在Theme设置View的默认样式，可以同时定义一个format为reference的属性att_a，在定义Theme时为这个attribute指定一个Style，并且在View的第二个构造函数中将R.attr.attr_a 作为第三个参数调用第三个构造函数 可以定义一个Style作为Theme中没有定义attr_a时View属性的默认值。 可以在Theme中直接为属性赋值，但优先级最低 当defStyleAttr（即View的构造函数的第三个参数）不为0且在Theme中有为这个attr赋值时，defStyleRes（通过obtainStyledAttributes的第四个参数指定）不起作用 属性值定义的优先级：xml&gt;style&gt;Theme中的默认Sytle&gt;默认Style（通过obtainStyledAttributes的第四个参数指定）&gt;在Theme中直接指定属性值 自定义控件 目前来说，自定义的控件主要采用三种方式： 对现有的控件进行扩展 通过组合的方式来实现新的控件 重写View来实现新的控件 现在，就分别来讨论这几种方式 对现有的控件进行扩展这种方式主要是对一些已有的基础控件进行扩展，例如TextView，Button等，我们可以通过对当前的控件进行扩展，来使得该控件变成我们想要的样子，而且还保证了控件的原始的功能 最简单的例子，如果我们想让一个TextView能够展示特殊的字体，或者展示我们设置的背景，但它的基本功能还是一个TextView，我们还是按照一个TextView的方式来使用它，这个时候我们就可以使用这种方式来创建一个自己的控件。 这里，我们通过一个例子来学习如何对现有控件进行扩展。我们来自定义一个字体可以渐变的TextView，这个效果在很多地方都会用到。 其实很简单，回想一下，一个控件的基础是View，它的绘制的过程我们之前已经讨论过了。我们只需要在回调函数里对控件进行设计即可。在原生的TextView里面，通过onDraw方法来绘制显示的文字。我们要想修改TextView的效果，可以在onDraw方法中来实现。 @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); } super.onDraw是TextView用来实现原生的功能的，我们可以在这个方法之前或者之后调用这个方法。我们可以先设置一下这个TextView的背景。​ @Override protected void onDraw(Canvas canvas) { Paint mPaint1 = new Paint(); mPaint1.setColor(getResources().getColor(android.R.color.holo_blue_light)); mPaint1.setStyle(Paint.Style.FILL); Paint mPaint2 = new Paint(); mPaint2.setColor(getResources().getColor(android.R.color.holo_red_light)); mPaint2.setStyle(Paint.Style.FILL); canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), mPaint1); canvas.drawRect(10, 10, getMeasuredWidth() - 10, getMeasuredHeight() - 10, mPaint2); super.onDraw(canvas); } 可以看出，绘制了两个大小不同的矩形，形成一个重叠的效果，然后再调用super.onDraw方法，让系统执行绘制文字的工作。这样，我们就通过很简单的方式，可以改变这个控件的绘制行为，形成一个新的控件。是不是觉得很简单啊？ 这个例子比较简单，还记得我们之前说的那个动态文字闪动的效果吗？其实也很简单，给TextView设置LinearGradient属性。然后在onDraw方法，通过矩阵不断移动，不断重新绘制 @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); if (mViewWith == 0) { mViewWith = getMeasuredWidth(); if (mViewWith &gt; 0) { mPaint = getPaint(); /** * LinearGradient第一个和第二个参数表示颜色渐变的起点 第三、第四表示颜色渐变的终点 第五个参数表示渐变的颜色 * 第六个参数可以为空,表示坐标,值为0-1 new float[] {0.25f, 0.5f, 0.75f, 1 } *如果这是空的，颜色均匀分布，沿梯度线 * 第七个表示平铺方式 * CLAMP重复最后一个颜色至最后 * MIRROR重复着色的图像水平或垂直方向已镜像方式填充会有翻转效果 *REPEAT重复着色的图像水平或垂直方向 */ mLinearGradient = new LinearGradient(0, 0, mViewWith, 0, new int[]{Color.parseColor(&quot;#7B68EE&quot;), Color.parseColor(&quot;#FFC0CB&quot;), Color.parseColor(&quot;#7B68EE&quot;)}, null, Shader.TileMode.MIRROR); mPaint.setShader(mLinearGradient); mMatrix = new Matrix(); } } } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); if (mMatrix != null) { mTranleate += mViewWith / 14; if (mTranleate &gt; 2 * mViewWith) { mTranleate = -mViewWith; } mMatrix.setTranslate(mTranleate, 0); mLinearGradient.setLocalMatrix(mMatrix); postInvalidateDelayed(100); } } 这里面涉及很多的画图的方式，这里不详细说明，不过如果想要更好的设计自己的控件，对Android的画图也是需要详细的了解的，这个问题我们可以在之后详细说明。 这个就是通过扩展原有控件来自定义自己的控件。还是很简单的，在onDraw方法里对控件进行重新的绘制，但一定注意保留super.onDraw方法，这样原有的控件的功能也会保留。 复合控件 1+1&gt;2这个章节我觉得是自定义控件的重头戏，我把它起名为1+1&gt;2，为什么这么说呢？因为其实在大多数的时候，我们可能并不是十分的了解Android的绘图技巧，或者有些需求是需要我们多个控件组合成一个新的控件。这时，往往就需要多个控件的配合使用。往往自定义控件的一个原因就是，有些控件会重复使用。例如我们经常看到的TitleBar，中间会有一个标题栏，左右通常会有一个按钮，这个是大部分app都会有的，但是不同的界面可能会对标题内容，字体颜色有所不同。按钮的回调也会有所不同，所以这个时候自定义一个TitleBar就显得十分的重要了。 自定义属性我们在自定义控件的时候，往往会传递一些属性值。在Andorid里面，我们可以通过values下面的文件attrs.xml来定义属性值。自定义属性值还是很容易的，主要是以下几步: 自定义一个CustomView类 编写values/attrs.xml，在其中编写declare-styleable和attr等标签元素 在布局文件中CustomView使用自定义的属性，这个时候不要忘记配置命名空间xmlns:custom=”http://schemas.android.com/apk/res-auto“ 在CustomView的构造方法中通过TypedArray获取 在这个例子中，我们自定义的属性值如下​ &lt;?xml version=”1.0” encoding=”utf-8”?&gt; 上面的属性值的含义我们在后面会详细解释 在布局文件中，设置相应的属性值 &lt;com.xys.mytopbar.Topbar xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:custom=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/topBar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; custom:leftBackground=&quot;@drawable/blue_button&quot; custom:leftText=&quot;Back&quot; custom:leftTextColor=&quot;#FFFFFF&quot; custom:rightBackground=&quot;@drawable/blue_button&quot; custom:rightText=&quot;More&quot; custom:rightTextColor=&quot;#FFFFFF&quot; custom:title=&quot;自定义标题&quot; custom:titleTextColor=&quot;#123412&quot; custom:titleTextSize=&quot;15sp&quot;&gt; &lt;/com.xys.mytopbar.Topbar&gt; 接下来看看如何获取这些属性值 TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.TopBar); // 从TypedArray中取出对应的值来为要设置的属性赋值 mLeftTextColor = ta.getColor( R.styleable.TopBar_leftTextColor, 0); mLeftBackground = ta.getDrawable( R.styleable.TopBar_leftBackground); mLeftText = ta.getString(R.styleable.TopBar_leftText); mRightTextColor = ta.getColor( R.styleable.TopBar_rightTextColor, 0); mRightBackground = ta.getDrawable( R.styleable.TopBar_rightBackground); mRightText = ta.getString(R.styleable.TopBar_rightText); mTitleTextSize = ta.getDimension( R.styleable.TopBar_titleTextSize, 10); mTitleTextColor = ta.getColor( R.styleable.TopBar_titleTextColor, 0); mTitle = ta.getString(R.styleable.TopBar_title); // 获取完TypedArray的值后，一般要调用 // recyle方法来避免重新创建的时候的错误 ta.recycle(); 我们是通过TypedArray这个参数来获取相应的属性值，是不是很简单啊。 使用的方式还是很简单的，这里我们讨论一个大家都不注意的一个细节：TypedArray我们通常都是在构造函数中，通过TypedArray来获取对应的属性值 TypedArray ta = context.obtainStyledAttributes(attrs,R.styleable.TopBar); 其实，大家有没有想过我们在view的构造函数中，已存在一个参数AttributeSet，这个参数似乎也是关于属性值的，它的作用是什么，我们为什么不直接用这个值呢？ 看看一个例子 public MyTextView(Context context, AttributeSet attrs) { super(context, attrs); int count = attrs.getAttributeCount(); for (int i = 0; i &lt; count; i++) { String attrName = attrs.getAttributeName(i); String attrVal = attrs.getAttributeValue(i); Log.e(TAG, &quot;attrName = &quot; + attrName + &quot; , attrVal = &quot; + attrVal); } // ==&gt;use typedarray ... } 输出​ MyTextView(4136): attrName = layout_width , attrVal = 100.0dip MyTextView(4136): attrName = layout_height , attrVal = 200.0dip MyTextView(4136): attrName = text , attrVal = helloworld MyTextView(4136): attrName = testAttr , attrVal = 520看起来似乎AttributeSet和TypeArray没有什么区别啊，别急，我们换个角度看看，我们修改一下属性值的引用方式，直接引用对象。 &lt;com.example.test.MyTextView android:layout_width=&quot;@dimen/dp100&quot; android:layout_height=&quot;@dimen/dp200&quot; zhy:testAttr=&quot;520&quot; zhy:text=&quot;@string/hello_world&quot; /&gt; 运行的结果变为了 MyTextView(4692): attrName = layout_width , attrVal = @2131165234 MyTextView(4692): attrName = layout_height , attrVal = @2131165235 MyTextView(4692): attrName = text , attrVal = @2131361809 MyTextView(4692): attrName = testAttr , attrVal = 520 &gt;&gt;use typedarray MyTextView(4692): text = Hello world! , textAttr = 520 看到这个，你是不是明白了什么，当我们引用的是对象的时候，AttributeSet得到的value是对象的名称 总结一下： 其实，TypedArray其实是用来简化我们的工作的，比如上例，如果布局中的属性的值是引用类型（比如：@dimen/dp100），如果使用AttributeSet去获得最终的像素值，那么需要第一步拿到id，第二步再去解析id。而TypedArray正是帮我们简化了这个过程。 如果通过AttributeSet获取最终的像素值的过程： int widthDimensionId = attrs.getAttributeResourceValue(0, -1); Log.e(TAG, &quot;layout_width= &quot;+getResources().getDimension(widthDimensionId)); 这回你可以和别人吹B，你知道TypedArray的作用了。 上面我们也可以看到，在attrs中，我们可以定义多种属性值，我们可以总结一下各种属性值的定义方式和使用方式。 reference：参考某一资源ID。 （1）属性定义： &lt;declare-styleable name = &quot;名称&quot;&gt; &lt;attr name = &quot;background&quot; format = &quot;reference&quot; /&gt; &lt;/declare-styleable&gt; （2）属性使用： &lt;ImageView android:layout_width = &quot;42dip&quot; android:layout_height = &quot;42dip&quot; android:background = &quot;@drawable/图片ID&quot;/&gt; color：颜色值。 （1）属性定义： &lt;declare-styleable name = &quot;名称&quot;&gt; &lt;attr name = &quot;textColor&quot; format = &quot;color&quot; /&gt; &lt;/declare-styleable&gt; （2）属性使用： &lt;TextView android:layout_width = &quot;42dip&quot; android:layout_height = &quot;42dip&quot; android:textColor = &quot;#00FF00&quot;/&gt; boolean：布尔值。（1）属性定义： &lt;declare-styleable name = &quot;名称&quot;&gt; &lt;attr name = &quot;focusable&quot; format = &quot;boolean&quot; /&gt; &lt;/declare-styleable&gt; （2）属性使用： &lt;Button android:layout_width = &quot;42dip&quot; android:layout_height = &quot;42dip&quot; android:focusable = &quot;true&quot;/&gt; dimension：尺寸值。 （1）属性定义： &lt;declare-styleable name = &quot;名称&quot;&gt; &lt;attr name = &quot;layout_width&quot; format = &quot;dimension&quot; /&gt; &lt;/declare-styleable&gt; （2）属性使用： &lt;Button android:layout_width = &quot;42dip&quot; android:layout_height = &quot;42dip&quot;/&gt; float：浮点值。 （1）属性定义： &lt;declare-styleable name = &quot;AlphaAnimation&quot;&gt; &lt;attr name = &quot;fromAlpha&quot; format = &quot;float&quot; /&gt; &lt;attr name = &quot;toAlpha&quot; format = &quot;float&quot; /&gt; &lt;/declare-styleable&gt; （2）属性使用： &lt;alpha android:fromAlpha = &quot;1.0&quot; android:toAlpha = &quot;0.7&quot;/&gt; integer：整型值。 （1）属性定义： &lt;declare-styleable name = &quot;AnimatedRotateDrawable&quot;&gt; &lt;attr name = &quot;frameDuration&quot; format=&quot;integer&quot; /&gt; &lt;attr name = &quot;framesCount&quot; format=&quot;integer&quot; /&gt; &lt;/declare-styleable&gt; （2）属性使用： &lt;animated-rotate xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot; android:drawable = &quot;@drawable/图片ID&quot; android:pivotX = &quot;50%&quot; android:pivotY = &quot;50%&quot; android:framesCount = &quot;12&quot; android:frameDuration = &quot;100&quot;/&gt; string：字符串。 （1）属性定义： &lt;declare-styleable name = &quot;MapView&quot;&gt; &lt;attr name = &quot;apiKey&quot; format = &quot;string&quot; /&gt; &lt;/declare-styleable&gt; （2）属性使用： &lt;com.google.android.maps.MapView android:layout_width = &quot;fill_parent&quot; android:layout_height = &quot;fill_parent&quot; android:apiKey = &quot;0jOkQ80oD1JL9C6HAja99uGXCRiS2CGjKO_bc_g&quot;/&gt; fraction：百分数。 （1）属性定义： &lt;declare-styleable name=&quot;RotateDrawable&quot;&gt; &lt;attr name = &quot;fromDegrees&quot; format = &quot;float&quot; /&gt; &lt;attr name = &quot;toDegrees&quot; format = &quot;float&quot; /&gt; &lt;attr name = &quot;pivotX&quot; format = &quot;fraction&quot; /&gt; &lt;attr name = &quot;pivotY&quot; format = &quot;fraction&quot; /&gt; &lt;/declare-styleable&gt; （2）属性使用： &lt;rotate xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot; android:fromDegrees = &quot;0&quot; android:toDegrees = &quot;360&quot; android:pivotX = &quot;200%&quot; android:pivotY = &quot;300%&quot; android:duration = &quot;5000&quot;/&gt; enum：枚举值。 （1）属性定义： &lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;orientation&quot;&gt; &lt;enum name=&quot;horizontal&quot; value=&quot;0&quot; /&gt; &lt;enum name=&quot;vertical&quot; value=&quot;1&quot; /&gt; &lt;/attr&gt; &lt;/declare-styleable&gt; （2）属性使用： &lt;LinearLayout xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot; android:orientation = &quot;vertical&quot; android:layout_width = &quot;fill_parent&quot; android:layout_height = &quot;fill_parent&quot;&gt; &lt;/LinearLayout&gt; flag：位或运算。 （1）属性定义： &lt;declare-styleable name=&quot;名称&quot;&gt; &lt;attr name=&quot;windowSoftInputMode&quot;&gt; &lt;flag name = &quot;stateUnspecified&quot; value = &quot;0&quot; /&gt; &lt;flag name = &quot;stateUnchanged&quot; value = &quot;1&quot; /&gt; &lt;flag name = &quot;stateHidden&quot; value = &quot;2&quot; /&gt; &lt;flag name = &quot;stateAlwaysHidden&quot; value = &quot;3&quot; /&gt; &lt;flag name = &quot;stateVisible&quot; value = &quot;4&quot; /&gt; &lt;flag name = &quot;stateAlwaysVisible&quot; value = &quot;5&quot; /&gt; &lt;flag name = &quot;adjustUnspecified&quot; value = &quot;0x00&quot; /&gt; &lt;flag name = &quot;adjustResize&quot; value = &quot;0x10&quot; /&gt; &lt;flag name = &quot;adjustPan&quot; value = &quot;0x20&quot; /&gt; &lt;flag name = &quot;adjustNothing&quot; value = &quot;0x30&quot; /&gt; &lt;/attr&gt; &lt;/declare-styleable&gt; （2）属性使用： &lt;activity android:name = &quot;.StyleAndThemeActivity&quot; android:label = &quot;@string/app_name&quot; android:windowSoftInputMode = &quot;stateUnspecified | stateUnchanged | stateHidden&quot;&gt; &lt;intent-filter&gt; &lt;action android:name = &quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 注意： 属性定义时可以指定多种类型值。 （1）属性定义： &lt;declare-styleable name = &quot;名称&quot;&gt; &lt;attr name = &quot;background&quot; format = &quot;reference|color&quot; /&gt; &lt;/declare-styleable&gt; （2）属性使用： &lt;ImageView android:layout_width = &quot;42dip&quot; android:layout_height = &quot;42dip&quot; android:background = &quot;@drawable/图片ID|#00FF00&quot;/&gt; 属性值的获取也很简单，我们可以在构造函数中获取TypedArray，通过TypedArray的get方法可以获取对应的值，这个比较简单，可以在第二个或者第三个构造函数中，通过context.obtainStyledAttributes方法来得到TypedArray​​ TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.属性分组的名字); // 从TypedArray中取出对应的值来为要设置的属性赋值 textColor = ta.getColor( R.styleable.属性分组名字_属性值名字, 0); 其中的getColor可以替换成你想要获得的属性值的类型，比如getString，getDrawable等等。 好了，这个属性值的部分就介绍到这里，这个还是比较简单的。","categories":[{"name":"自定义view","slug":"自定义view","permalink":"http://vincent890120.github.io/categories/自定义view/"}],"tags":[{"name":"view","slug":"view","permalink":"http://vincent890120.github.io/tags/view/"}]},{"title":"Android Studio分享library到jcenter","slug":"将Android-library分享到jcenter","date":"2016-03-30T11:54:44.000Z","updated":"2017-09-20T07:00:05.000Z","comments":true,"path":"2016/03/30/将Android-library分享到jcenter/","link":"","permalink":"http://vincent890120.github.io/2016/03/30/将Android-library分享到jcenter/","excerpt":"","text":"Android studio 是从哪里得到库的？我们先从这个简单的问题开始，我相信不是每个人都完全明白Android studio 是从哪里得到这些library的。莫非就是Android studio 从google搜索然后下载了一个合适的给我们？其实，没有那么复杂。Android Studio是从build.gradle里面定义的Maven 仓库服务器上下载library的。Apache Maven是Apache开发的一个工具，提供了用于贡献library的文件服务器。总的来说，只有两个标准的Android library文件服务器：jcenter 和 Maven Central。在这里，由于Maven Central使用的并不如jcenter广泛，我们重点讨论jcenter。 jcenter和Maven Central为何有两个标准的仓库？事实上两个仓库都具有相同的使命：提供Java或者Android library服务。上传到哪个（或者都上传）取决于开发者。起初，Android Studio 选择Maven Central作为默认仓库。如果你使用老版本的Android Studio创建一个新项目，mavenCentral()会自动的定义在build.gradle中。但是Maven Central的最大问题是对开发者不够友好。上传library异常困难。上传上去的开发者都是某种程度的极客。同时还因为诸如安全方面的其他原因，Android Studio团队决定把默认的仓库替换成jcenter。正如你看到的，一旦使用最新版本的Android Studio创建一个项目，jcenter()自动被定义，而不是mavenCentral()。有许多将Maven Central替换成jcenter的理由，下面是几个主要的原因。 jcenter通过CDN发送library，开发者可以享受到更快的下载体验。 jcenter是全世界最大的Java仓库，因此在Maven Central 上有的，在jcenter上也极有可能有。换句话说jcenter是Maven Central的超集。 上传library到仓库很简单，不需要像在 Maven Central上做很多复杂的事情。 友好的用户界面 如果你想把library上传到 Maven Central ，你可以在bintray网站上直接点击一个按钮就能实现。 基于上面的原因以及我自己的经验，可以说替换到jcenter是明智之举。所以我们这篇文章将把重心放在jcenter，反正如果你能成功把library放在jcenter，转到 Maven Central 是非常容易的事情。 jcenterjcenter是一个由 bintray.com维护的Maven仓库。我们可以在这里看到整个仓库的内容。还记得我们经常在build.gradle中定义的如下代码吗？​ buildscript { repositories { jcenter() } dependencies { classpath ‘com.android.tools.build:gradle:1.2.3’ } }其中jcenter( )代表了我们会使用jcenter的maven仓库。 gradle是如何从仓库上获取一个library的？在讨论如何上传library到jcenter之前，我们先看看gradle是如何从仓库获取library的。比如我们在 build.gradle输入如下代码的时候，这些库是如果奇迹般下载到我们的项目中的。​ compile ‘com.example.vincent.scrolllistview:scrolllistview:0.0.2’ 一般来说，我们需要知道library的字符串形式，包含3部分​ GROUP_ID:ARTIFACT_ID:VERSION GROUP_ID: com.example.vincent.scrolllistview ARTIFACT_ID: scrolllistview VERSION: 0.0.2 具体含义 GROUP_ID:library的group。有可能在同样的上下文中存在多个不同功能的library。如果library具有相同的group，那么它们将共享一个GROUP_ID。通常我们以开发者包名紧跟着library的group名称来命名，比如com.squareup.picasso。 ARTIFACT_ID:library的真实名称。 VERSION:就是版本号而已，虽然可以是任意文字，但是我建议设置为x.y.z的形式，如果喜欢还可以加上beta这样的后缀。 下面是Square library的一个例子。你可以看到每个都可以很容易的分辨出library和开发者的名称。​ dependencies { compile ‘com.squareup:otto:1.3.7’ compile ‘com.squareup.picasso:picasso:2.5.2’ compile ‘com.squareup.okhttp:okhttp:2.4.0’ compile ‘com.squareup.retrofit:retrofit:1.9.0’ }那么在添加了上面的依赖之后会发生什么呢？简单。Gradle会询问Maven仓库服务器这个library是否存在，如果是，gradle会获得请求library的路径，一般这个路径都是这样的形式：GROUP_ID/ARTIFACT_ID/VERSION_ID。然后Android Studio 将下载这些文件到我们的电脑上，与我们的项目一起编译。整个过程就是这么简单，一点都不复杂。其实很简单，从仓库上下载的library只是存储在仓库服务器上的jar或者aar文件而已。有点类似于自己去下载这些文件，拷贝然后和项目一起编译。但是使用gradle依赖管理的最大好处是你除了添加几行文字之外啥也不做。library一下子就可以在项目中使用了。 aar文件仓库中存储的有两种类型的library：jar 和 aar。jar文件大家都知道，但是什么是aar文件呢？aar文件时在jar文件之上开发的。之所以有它是因为有些Android Library需要植入一些安卓特有的文件，比如AndroidManifest.xml，资源文件，Assets或者JNI。这些都不是jar文件的标准。因此aar文件就时发明出来包含所有这些东西的。总的来说它和jar一样只是普通的zip文件，不过具有不同的文件结构。jar文件以classes.jar的名字被嵌入到aar文件中。其余的文件罗列如下： /AndroidManifest.xml (mandatory) /classes.jar (mandatory) /res/ (mandatory) /R.txt (mandatory) /assets/ (optional) /libs/*.jar (optional) /jni//*.so (optional) /proguard.txt (optional) /lint.jar (optional)可以看到.aar文件是专门为安卓设计的。既然我们是Android开发攻城狮，当然这里主要是讲的是上传aar形式的library。 上传library到jcenter前面都是讲了一些基础的知识，终于到了关键的时刻，下面仔细讲一下怎么将library上传到jcenter 在bintray上创建package第一步：在bintray.com上注册一个账号。第二步：完成注册之后，登录网站，然后点击maven。第三步：点击Add New Package，为我们的library创建一个新的package。第四步：输入所有需要的信息这步很简单，主要是对一些信息的填写虽然如何命名包名没有什么限定，但是也有一定规范。所有字母应该为小写，单词之间用－分割，比如，fb-like。(我这里没有用-分隔符，哈哈，第一次，希望大家还是按照规定比较好)当每项都填完之后，点击Create Package。搞定，这样，我们就已经创建了一个在Bintray上的Maven库。 创建Android Studio项目很多情况下，我们需要同时上传一个以上的library到仓库，也可能不需要上传东西。因此我建议最好将每部分分成一个Module。最好分成两个module，一个Application Module一个Library Module。Application Module用于展示库的用法，Library Module是library的源代码。如果你的项目有一个以上的library，尽管创建另外的module：1个 module对应1 个library。关于如何创建一个新的module，我这里简单说一下。其实很简单。 Android Studio中为项目新建及添加Library1.新建项目就不用说了吧，现在来新建一个Module2.打开如下图，其中有新建Android Library 和 Import Existing Project，我们来新建一个3.我们会发现多出来了一个Module，和Eclipse里两个项目在一个空间里一样4.右击Module（项目）选择open Module Settings,会出现如下图所示，然后选择3 Module dependencies，再选你刚才新建的Library这样就可以新建了一个module了。 修改gradle文件刚刚我们新建了新的module了，我们需要添加bintray的插件，这里修改项目的build.gradle​ buildscript { repositories { jcenter() } dependencies { classpath ‘com.android.tools.build:gradle:1.5.0’ classpath ‘com.android.tools.build:gradle:1.2.3’ classpath ‘com.jfrog.bintray.gradle:gradle-bintray-plugin:1.2’ classpath ‘com.github.dcendents:android-maven-gradle-plugin:1.3’ } }接下来我们将修改local.properties。在里面定义api key的用户名以及被创建key的密码，用于bintray的认证。之所以要把这些东西放在这个文件是因为这些信息时比较敏感的，不应该到处分享，包括版本控制里面。幸运的是在创建项目的时候local.properties文件就已经被添加到.gitignore了。因此这些敏感数据不会被误传到git服务器。下面是要添加的二行代码： bintray.user=YOUR_BINTRAY_USERNAME bintray.apikey=YOUR_BINTRAY_API_KEY //实例 bintray.user=vincent890120 bintray.apikey=39a8f8fa018cee528e8825a487c600e017d2d86e bintray.user：填写你的Bintray的用户名bintray.apikey：API Key可以在Edit Profile页面的API Key 选项卡中找到。最后要修改的是module的build.gradle文件。注意前面修改的是项目的build.gradle文件。打开它，在apply plugin: ‘com.android.library’之后添加这几行，如下：​ ext { bintrayRepo = ‘maven’ //默认 bintrayName = ‘scrolllistview’ //创建的 package name publishedGroupId = &apos;com.example.vincent.scrolllistview&apos; libraryName = &apos;ScrollListView&apos; artifact = &apos;scrolllistview&apos; libraryDescription = &apos;a listview that can scroll in android&apos; siteUrl = &apos;https://github.com/vincent890120/ScrollListView&apos; gitUrl = &apos;https://github.com/vincent890120/ScrollListView.git&apos; libraryVersion = &apos;0.0.2&apos; developerId = &apos;vincent890120&apos; developerName = &apos;vincent&apos; developerEmail = &apos;vincent890120@126.com&apos; licenseName = &apos;The Apache Software License, Version 2.0&apos; licenseUrl = &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos; allLicenses = [&quot;Apache-2.0&quot;] } 最后在文件的后面追加两行如下的代码来应用两个脚本，用于构建library文件和上传文件到bintray（为了方便，我直接使用了github上连接到相关文件的链接）：​ apply from: ‘https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle‘ apply from: ‘https://raw.githubusercontent.com/nuuneoi/JCenter/master/bintrayv1.gradle‘ 完整的build.gradle文件如下： apply plugin: &apos;com.android.library&apos; ext { bintrayRepo = &apos;maven&apos; bintrayName = &apos;scrolllistview&apos; publishedGroupId = &apos;com.example.vincent.scrolllistview&apos; libraryName = &apos;ScrollListView&apos; artifact = &apos;scrolllistview&apos; libraryDescription = &apos;a listview that can scroll in android&apos; siteUrl = &apos;https://github.com/vincent890120/ScrollListView&apos; gitUrl = &apos;https://github.com/vincent890120/ScrollListView.git&apos; libraryVersion = &apos;0.0.2&apos; developerId = &apos;vincent890120&apos; developerName = &apos;vincent&apos; developerEmail = &apos;vincent890120@126.com&apos; licenseName = &apos;The Apache Software License, Version 2.0&apos; licenseUrl = &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos; allLicenses = [&quot;Apache-2.0&quot;] } android { compileSdkVersion 23 buildToolsVersion &quot;23.0.2&quot; defaultConfig { minSdkVersion 15 targetSdkVersion 23 versionCode 1 versionName &quot;1.0&quot; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard- rules.pro&apos; } } } dependencies { compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;junit:junit:4.12&apos; compile &apos;com.android.support:appcompat-v7:23.1.1&apos; } apply from: &apos;https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle&apos; apply from: &apos;https://raw.githubusercontent.com/nuuneoi/JCenter/master/bintrayv1.gradle&apos; 把library上传到bintray空间现在是上传library到你自己的bintray仓库上的时候了。请到Android Studio的终端（Terminal）选项卡。第一步是检查代码的正确性，以及编译library文件（aar，pom等等），输入下面的命令：​ &gt; gradle install 如果没有什么问题，会显示：​ BUILD SUCCESSFUL现在我们已经成功一半了。下一步是上传编译的文件到bintray，使用如下的命令：​ gradle bintrayUpload如果没有什么问题，会显示：​ SUCCESSFUL在bintray的网页上检查一下你的package。你会发现在版本区域的变化。恭喜，你的library终于放在了互联网上，任何人都可以使用了！不过也别高兴过头，library现在仍然只是在你自己的Maven仓库，而不是在jcenter上。如果有人想使用你的library，他必须定义仓库的url，如下：​ repositories { maven { url ‘https://dl.bintray.com/vincent890120/maven/‘ } } ... dependencies { compile &apos;com.example.vincent.scrolllistview:scrolllistview:0.0.1&apos; } 你可以在bintray的web界面找到自己Maven仓库的url，或者直接吧vincent890120替换成你的bintray用户名（因为前面部分其实都是一样的）。我还建议你直接访问那个链接，看看里面到底是什么。 但是，就如我们前面所讲的那样，让开发者去定义url这种复杂的事情并不是分享library的最佳方式。想象一下，使用10个library不得添加10个url？所以为了更好的体验，我们把library从自己的仓库传到jcenter上。 同步bintray用户仓库到jcenter把library同步到jcenter非常容易。只需访问网页并点击Add to JCenter，这时你会发现自己的项目会有变化了 从此之后，任何开发者都可以使用jcenter() repository 外加一行gradle脚本来使用我们的library了​ compile ‘com.example.vincent.scrolllistview:scrolllistview:0.0.1’ 当我们想修改和升级的时候，不要忘了修改​ libraryVersion = ‘0.0.2’这样 上传之后会自动生成一个新的版本 到这里，全部的内容就结束了，赶快上传一个自己的项目到maven库吧，是不是很酷啊。","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://vincent890120.github.io/categories/环境搭建/"}],"tags":[{"name":"jcenter","slug":"jcenter","permalink":"http://vincent890120.github.io/tags/jcenter/"}]},{"title":"Android控件架构","slug":"Android控件架构","date":"2016-03-22T05:37:06.000Z","updated":"2017-09-20T09:02:26.000Z","comments":true,"path":"2016/03/22/Android控件架构/","link":"","permalink":"http://vincent890120.github.io/2016/03/22/Android控件架构/","excerpt":"","text":"自定义控件，是每一个Android开发工程师打怪升级的必经之路，经常看到gitHub上的大神展示的酷炫的控件，有没有冲动也想自己写一个酷炫的控件让别人膜拜？没有问题，从根本上了解view的创建过程，其实自定义控件并没有你想象的那么复杂，一起玩转View吧！ Android控件的结构控制树要想能够自定义一个控件，我们首先需要做的就是去了解一个控件的结构。对于Android来说，控件大致可以分为两类：ViewGroup和View。其中ViewGroup作为父控件可以包含多个View和ViewGroup，并形成了一个树状的结构，我们称为控制树。控制树的结构如下图所示： 在每一个控制树的顶端都有一个ViewParent对象，是整个树的核心，所有的交互都由它来管理。 UI界面框架对于一个Activity来说，其UI的界面框架如下： 可以看出，每一个Activity都会包含一个Window对象，在Android中，这个具体的Window对象是由PhoneWindow实现的(这里简单说明，不详细讲解，其实PhoneWindow是Window的一个实现类)。在PhoneWindow中将一个DecorView设置为整个界面的根View。DecorView包含两个部分，一个是TitleView，一个是ContentView。相信看到ContentView大家一定会非常熟悉了，它其实是一个ID为content的FrameLayout，我们通常的main_activity就是设置在这个FrameLayout中。那我们进一步将我们的控制树完善一下，一个标准的视图树的模型如下：从上图可以看出，第二层是一个LinearLayout，作为整个树的ViewGroup，它包含两个布局，一个是TitleBar，一个是Content，还记得我们经常会通过设置requestWindowFeature(Window.FEATURE_NO_TITLE)来设置全屏吗？这样屏幕就只会剩下一个Content的View了，但也要注意，我们要在setContentView之前来调用requestWindowFeature的方法才能生效。在代码中，我们在onCreate方法中调用setContentView后，ActivityManagerService会调用onResume的方法，这样，系统才会把整个DecorView添加到PhoneWindow上，显示出来，完成最终界面的绘制。通过 ViewGroup content = (ViewGroup)findViewById(android.R.id.content) 可以得到当前的content，通过以下方式可以获得对应设置的View content.getChild(0) 这篇文章主要是笼统的介绍一下一个标准的Android控件的结构，有很多地方都没有深入讨论，因为我们这个章节主要讨论的是如何去自定义view，所以更底层的内容，可以放到以后去讨论，下面主要会对view的绘制进行一个研究,讨论的重点也会围绕View的三个流程 Measure,Layout,Draw。","categories":[{"name":"自定义view","slug":"自定义view","permalink":"http://vincent890120.github.io/categories/自定义view/"}],"tags":[{"name":"view","slug":"view","permalink":"http://vincent890120.github.io/tags/view/"}]},{"title":"使用github和hexo搭建属于自己的博客","slug":"Hellohexo","date":"2016-03-21T06:24:48.000Z","updated":"2017-09-20T06:57:44.000Z","comments":true,"path":"2016/03/21/Hellohexo/","link":"","permalink":"http://vincent890120.github.io/2016/03/21/Hellohexo/","excerpt":"","text":"前言为什么要搭建属于自己的博客博客，分享知识，共同进步。很早之前就想自己搭建一个博客，把一些正在学习的知识记录下来，但一直很懒，正好最近在看书，发现看完之后过了一段时间就会忘掉，看来年纪大了，记性不行了，那就索性把自己理解的内容记录下来。毛主席说过，好记性不如烂笔头，脚踏实地，多多学习，多多总结。 为什么选择这种方式搭建博客之前也看过不少的博客，CSDN，简书，都云集了各路大神，最后也是同事的推荐，选择了用hexo+github的方式来搭建属于自己的博客。原因很简单，开源的东西，永远是一个coder最喜欢的方式。 GitHubGitHub的注册相信每一个coder对GitHub都不会陌生，它对于我们来说就是像是一个“淘宝”，在上面永远会有你需要的东西，当然，我们的博客的搭建的基础也是在GitHub上面，所以，没有注册的小伙伴，第一步就是去注册一个属于你自己的开源世界吧。 GitHub Pages我们能够搭建一个hexo博客，根本原因是github支持了我们建立个人站点，其实，搭建的方式很简单，按照GitHub Pages提供的指引，我相信大家都能够很顺利的设置自己个人的站点。 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo的安装可以根据hexo官方文档的文档进行安装。 hexo的建站 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。​hexo init cd &lt;folder&gt; npm install 安装好了之后我们需要配置Hexo好了，我们大致熟悉了结构后就要开始配置hexo了，地点当然是_config.yml了请出我们文档的相关索引我们要关心的就几个地方 title 网站标题 description 可以是名言什么的 author 作者 language语言 deploy:type: gitrepository: https://github.com/username/username.github.io.gitbranch: master 编译Hexo执行以下命令 hexo g hexo s这里可能有会有错误提示Error: Deployer not found : git可以在项目目录下执行 npm install hexo-deployer-git –save在浏览器上输入http://localhost:4000/就可以看到我们带默认主题的hexo了，接下来我们要部署要GitHub上去还记得我们在_config.yml配置了deploy吗，这就是用来部署的配置 hexo g hexo d我们现在在输入 http://username.github.io进入了我们自己的博客 next主题有没有发现，Hexo自带的主题真是有点丑，不用担心，我们可以添加其他的主题，这里介绍的是普遍使用的next主题可以根据官方的next文档经行操作，这里面介绍了整个next是的使用方式和配置方式 新建文章 在我们的项目地址上执行 $ hexo new [layout] hexo g hexo d 第二步后会在source的草稿目录里会有个md文件，在 Mac OS X 上，我强烈建议你用 Mou 这款免费且十分好用的 Markdown 编辑器，它支持实时预览，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://vincent890120.github.io/categories/环境搭建/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://vincent890120.github.io/tags/hexo/"}]}]}